<!DOCTYPE html>
<html lang="zh-tw">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="這是一個網頁設計想法每日更新">
  <title>二欄式版型示例 Leetcode題目與解法</title>
  
  <!-- Favicon 範例 -->
  <!-- 可選：PNG 格式 -->
  <link rel="icon" href="favicon.png" type="image/png">
    
  <style>
    header {
      background-color: #343a40;
      color: white;
      padding: 20px 0;
    }

    footer {
      background-color: #343a40;
      color: white;
      padding: 20px 0;
      text-align: center;
    }
	
  </style>
  	
  <!-- Bootstrap 5 CSS CDN -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4Q6Gf2aSP4eDXB8Miphtr37CMZZQ5oXLH2yaXMJ2w8e2ZtHTl7GptT4jmndRuHDT" crossorigin="anonymous">
  
</head>
<body>

  <header>
    <h1 id="site-title">Leetcode題目與解法</h1>
	
	
	<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
	
	<div class="border border-light rounded p-2">
	
	<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
      <span class="navbar-toggler-icon"></span>
	  Nav應用
    </button>
	
	<!-- 折疊區塊 -->
	<div class="collapse navbar-collapse" id="navbarNav">
    <ul class="navbar-nav ms-auto">
	  <li class="nav-item"><a class="nav-link"  href="index.html">首頁</a></li>
      <li class="nav-item"><a class="nav-link"  href="#page">新消息</a></li>
	  <li class="nav-item"><a class="nav-link"  href="about.html">靜態網頁方向</a></li>
	  <li class="nav-item"><a class="nav-link"  href="technology.html">網頁技術</a></li>
    </ul>
	</div>
	
	</div>
    </nav>
	
  </header>

  
  <main class="container-fluid px-0">
    <div class="row gx-0">
	
    <aside class="col-md-3 bg-light p-3 sidebar">
      <h2>側邊欄</h2>
	  <p>1. Two Sum</p>
	 
    </aside>
	
	
    <section class="content col-md-9 p-3">
        <h1 class="text-center mb-4">Two Sum Problem</h1>
        
        <!-- 英文部分 -->
        <div class="row mb-4">
            <div class="col-12">
                <h3>English</h3>
                <p>
                    Given an array of integers <code>nums</code> and an integer <code>target</code>, 
                    return indices of the two numbers such that they add up to <code>target</code>.
                    You may assume that each input would have exactly one solution, 
                    and you may not use the same element twice.
                    <br><br>
                    You can return the answer in any order.
                </p>
                <h5>Example 1:</h5>
                <pre><code>Input: nums = [2,7,11,15], target = 9
							Output: [0,1]
							Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</code></pre>

                <h5>Example 2:</h5>
                <pre><code>Input: nums = [3,2,4], target = 6
							Output: [1,2]</code></pre>
                <h5>Example 3:</h5>
                <pre><code>Input: nums = [3,3], target = 6
							Output: [0,1]</code></pre>

                <h5>Constraints:</h5>
                <ul>
                    <li>2 <= nums.length <= 104</li>
                    <li>-109 <= nums[i] <= 109</li>
                    <li>-109 <= target <= 109</li>
                    <li>Only one valid answer exists.</li>
                </ul>

                <h5>Follow-up:</h5>
                <p>Can you come up with an algorithm that is less than O(n²) time complexity?</p>
            </div>
        </div>

        <!-- 中文部分 -->
        <div class="row mb-4">
            <div class="col-12">
                <h3>中文</h3>
                <p>
                    給定一個整數陣列 <code>nums</code> 和一個整數 <code>target</code>，
                    傳回這兩個數字的索引，使它們總和等於 <code>target</code>。
                    可以假設每個輸入只有一個解，
                    不能重複使用同一個元素。
                    <br><br>
                    可以按任意順序返回答案。
                </p>

                <h5>範例 1:</h5>
                <pre><code>輸入: nums = [2,7,11,15], target = 9
							輸出: [0,1]
							解釋: 因為 nums[0] + nums[1] == 9, 我們返回 [0, 1]。</code></pre>

                <h5>範例 2:</h5>
                <pre><code>輸入: nums = [3,2,4], target = 6
							輸出: [1,2]</code></pre>

                <h5>範例 3:</h5>
                <pre><code>輸入: nums = [3,3], target = 6
							輸出: [0,1]</code></pre>

                <h5>約束條件:</h5>
                <ul>
                    <li>2 <= nums.length <= 104</li>
                    <li>-109 <= nums[i] <= 109</li>
                    <li>-109 <= target <= 109</li>
                    <li>只有一個有效答案。</li>
                </ul>

                <h5>延伸問題:</h5>
                <p>你能想出一個時間複雜度小於 O(n²) 的演算法嗎？</p>
            </div>
        </div>

        <!-- 解法 -->
        <div class="row">
            <div class="col-12">
                <h3>解法</h3>
                <pre><code>class Solution {
							public int[] twoSum(int[] nums, int target) {
								for(int i=0;i<nums.length;i++){
									int diff = target - nums[i];
									for(int j=0;j<nums.length;j++){
										if(nums[j] == diff && j != i){
											return new int[]{i,j};
										}
									}
								}
								return null;
							}
							}</code></pre>
                <p><strong>步驟:</strong></p>
                <ul>
                    <li>按造順序選擇陣列數值與target相減獲取另一個值 diff</li>
                    <li>按造順序找出另一個值 diff</li>
                    <li>找出後回傳一個新陣列 <code>[i,j]</code></li>
                </ul>
                <p><strong>時間複雜度:</strong> O(n²), <strong>記憶體複雜度:</strong> O(1)</p>

                <h5>優化建議:</h5>
                <p>通過使用 <code>HashMap</code> 來降低時間複雜度。將 <code>HashMap</code> 用來記錄已經遍歷過的元素，可以讓查找差值 diff 的操作變成 O(1)，進而將時間複雜度優化到 O(n)</p>

                <pre><code>import java.util.HashMap;

							class Solution {
								public int[] twoSum(int[] nums, int target) {
									HashMap<Integer, Integer> map = new HashMap<>();
									for (int i = 0; i < nums.length; i++) {
										int diff = target - nums[i];
										if (map.containsKey(diff)) {
											return new int[]{map.get(diff), i};
										}
										map.put(nums[i], i);
									}
									return null;
								}
							}</code></pre>
                <p><strong>優化後的時間複雜度:</strong> O(n), <strong>優化後的記憶體複雜度:</strong> O(n)</p>
            </div>
        </div>
	 
	  
    </section>
	
	</div>
  </main>

  <footer>
    <p>&copy; 2025 此網頁每日有空就會更新</p>
	<p>&copy; 2025 目前網頁方向為資訊....</p>
	<p>&copy; 2025 隱私權未來加入cookie紀錄....</p>
  </footer>

  
  <!-- Bootstrap 5 JS Bundle CDN (includes Popper) -->
  <!-- bootstrap.bundle.min.js  包含了 Bootstrap JS + Popper-->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/js/bootstrap.bundle.min.js" integrity="sha384-j1CDi7MgGQ12Z7Qab0qlWQ/Qqz24Gc6BM0thvEMVjHnfYGF0rmFCozFSxQBxwHKO" crossorigin="anonymous"></script>
  
  <!-- cookie 設定 -->
  <script src="writedatacookie.js"></script>

  
  
  
  </body>
</html>